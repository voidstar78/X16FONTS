REM COMMANDER X16 FONT EDITOR (FOR BASLOAD)
REM VOIDSTAR SEPT 2023

  VR = $B000:REM VIDEO BASE MEMORY
	FB = $F000:REM FONT BASE (INSIDE OF VIDEO MEMORY)
	
	BG=6:REM DEFAULT BACKGROUND COLOR (BASIC)
	B1=$61:REM THIS IS DEFAULT VPOKE DISPLAY COLOR (DIFFERENT COLOR CODES THAN BASIC)

  CR=1:REM CURRENT ROW IN CHAR DISPLAY
	CC=1:REM CURRENT COL IN CHAR DISPLAY
	
	FR=1:REM CURRENT ROW IN FONT DISPLAY
	FC=1:REM CURRENT COL IN FONT DISPLAY
		
	REM OTHER VARIABLES
	REM A$, A  KEYBOARD INPUT
	REM CA,CB USED AS TEMPORARY STORE IN INVERT
	REM X,Y,D USED IN THE POKE FEATURES AT END
	REM D AND D1 ALSO USED FOR DISPLAY FONT ADDRESS OFFSETS
	REM I,I2,I3 USED AS GENERAL COUNTERS
	REM K1 USED TO INDICATE WHERE TO START THE PRINT-CODES INDEXING FROM
	REM PE USED AS PETSCII PRINTABLE VS NONPRINTABLE TABLE
	K1 = $80	
	
	RZ=CR:REM TARGET ROW IN CHAR DISPLAY
	CZ=CC:REM TARGET COL IN CHAR DISPLAY
	
	RY=FR:REM TARGET ROW IN FONT DISPLAY
	CY=FC:REM TARGET COL IN FONT DISPLAY

STARTFRESH:
  COLOR 1,BG:REM WHITE ON BLUE
  SCREEN 3:REM 40 COL, 30 ROW
	
	COLOR 0,BG
	LOCATE 1,39
	PRINT "V*";	
	
	COLOR 4,BG
	LOCATE 1,2
	PRINT "DISPLAY-CODES";
	
	LOCATE 1,24
	PRINT "CURRENT-FONT";	
	
	LOCATE 20,1	
	PRINT "PRINT-CODES (CHR$)";
	COLOR 1,BG
	
	LOCATE 21,4	
	PRINT "$0123456789ABCDEF";
	COLOR 1,BG

  GOSUB SHOWHELP
  GOSUB SHOWFONTS:REM PRINT-CODES AT BOTTOM
  GOSUB SHOWDISPFONT:REM DISPLAY-CODES AT TOP
	GOSUB UPDATEDISP:REM UPDATE "CURRENT FONT"

MAINLOOP:  

  REM GET KEYBOARD INPUT
  GET A$
	A=ASC(A$):REM CONVERT STRING TO NUMERIC

  REM CHARACTER MAP DISPLAY MOVEMENT
  IF A = 87  THEN RZ=RZ-1:GOSUB UPDATEDISP:REM 'W'
  IF A = 83  THEN RZ=RZ+1:GOSUB UPDATEDISP:REM 'S'	
	IF A = 65  THEN CZ=CZ-1:GOSUB UPDATEDISP:REM 'A'
	IF A = 68  THEN CZ=CZ+1:GOSUB UPDATEDISP:REM 'D'

  REM FONT DISPLAY MOVEMENT
  IF A = 145 THEN RY=RY-1:GOSUB UPDATEDISP:REM UP ARROW
  IF A = 17  THEN RY=RY+1:GOSUB UPDATEDISP:REM DOWN ARROW	
	IF A = 157 THEN CY=CY-1:GOSUB UPDATEDISP:REM LEFT ARROW
	IF A = 29  THEN CY=CY+1:GOSUB UPDATEDISP:REM RIGHT ARROW
	
	IF A = 66  THEN         GOTO  CYCLEBACKG:REM 'B'
	
	IF A = 89  THEN BM=1   :GOSUB MOVBIToUP:GOSUB UPDATEDISP:REM MOVE ALL FONT BITS UP 'Y'
	IF A = 72  THEN BM=2   :GOSUB MOVBIToDOWN:GOSUB UPDATEDISP:REM MOVE ALL FONT BITS DOWN 'H'
	IF A = 71  THEN BM=3   :GOSUB MOVBIToLEFT:GOSUB UPDATEDISP:REM MOVE ALL FONT BITS LEFT 'G'
	IF A = 74  THEN BM=4   :GOSUB MOVBIToRIGHT:GOSUB UPDATEDISP:REM MOVE ALL FONT BITS RIGHT 'J'
	
	IF A = 32  THEN GOSUB TOGGLEBIT:GOSUB UPDATEDISP:REM SPACEBAR
  IF A = 73  THEN GOSUB CHOOSEINVERT:GOSUB UPDATEDISP:REM 'I' FOR INVERT
	IF A = 67  THEN GOSUB CLEARBITS:GOSUB UPDATEDISP:REM 'C' FOR CLEAR ALL
	IF A = 69  THEN GOSUB SETBITS:GOSUB UPDATEDISP:REM 'S' FOR SET ALL
	IF A = 75  THEN GOSUB COPYCHAR:GOSUB UPDATEDISP:REM 'K' FOR COPY
	
	IF A = 86  THEN GOSUB SAVECURR:REM SAVE 'V'
	IF A = 76  THEN GOSUB LOADCURR:GOSUB UPDATEDISP:REM LOAD 'L'
	IF A = 88  THEN GOSUB DOEXPORT:REM 'X' EXPORT COMMAND
	IF A = 81  THEN GOSUB DOIMPORTALL:REM 'Q' IMPORT COMMAND
	IF A = 90  THEN GOSUB DOEXPORTALL:REM 'Z' EXPORT COMMAND
	
	ZZ = 0:REM ASSUME THAT WE DON'T NEED TO UPDATE THE DISPLAY-FONTS
	IF A = 93  THEN K1=K1+128:ZZ=1:IF (K1 > 255) THEN K1 = 0:REM KEY ']' INCREMENT
	IF A = 91  THEN K1=K1-128:ZZ=1:IF (K1 < 0) THEN K1=128:REM KEY '[' DECREMENT
	IF (ZZ = 1) THEN GOSUB SHOWFONTS:REM SIGNAL THAT UPDATE DISPLAY-FONT IS NEEDED
	
	IF A = 27  THEN GOTO TERMINATE:REM ESCAPE

  GOTO MAINLOOP
	
UPDATEDISP:
  REM REVERT CURRENT DISP COLOR
  X = CC
	Y = CR
	D = B1:REM COLOR CODE	
  GOSUB COLORXY
	REM (REVERTING FONT COLOR NOT NECESSARY SINCE PRINT BIN$ WILL RESTORE IT ANYWAY)
  
	COLOR 13,BG
	
  REM UPDATE CHARACTER DISPLAY MARKERS
  LOCATE CR+1,18
	PRINT " ";:REM ERASE THE PREVIOUS COL MARKER
	IF (RZ > 16) THEN RZ = 1
	IF (RZ < 1) THEN RZ = 16
	CR=RZ
	LOCATE CR+1,18
	PRINT CHR$($5F);

  LOCATE 18,CC+1
	PRINT " ";:REM ERASE THE PREVIOUS COL MARKER
	IF (CZ > 16) THEN CZ = 1
	IF (CZ < 1) THEN CZ = 16
	CC=CZ
	LOCATE 18,CC+1
	PRINT "^";	
	
	REM UPDATE FONT DISPLAY MARKERS
  LOCATE FR+1,38
	PRINT " ";:REM ERASE THE PREVIOUS COL MARKER
	IF (RY > 8) THEN RY = 1
	IF (RY < 1) THEN RY = 8
	FR=RY
	LOCATE FR+1,38
	PRINT CHR$($5F);

  LOCATE 10,FC+29
	PRINT " ";:REM ERASE THE PREVIOUS COL MARKER
	IF (CY > 8) THEN CY = 1
	IF (CY < 1) THEN CY = 8
	FC=CY
	LOCATE 10,FC+29
	PRINT "^";

	D=FB + ((((CR-1)*16)+(CC-1))*8)
		
  COLOR 3,BG
	FOR I = 1 TO 8
	  LOCATE 1+I,24
		PRINT "$";HEX$(D);
	  V=VPEEK(1,D)
		LOCATE 1+I,30
		PRINT BIN$(V);
		D=D+1
	NEXT I
	
	REM SHOW THE CURRENT DISPLAY FONT INDEX
	LOCATE 1,15:PRINT "    ";:REM ERASE PRIOR ONE
	LOCATE 1,15:PRINT (((CR-1)*16)+(CC-1))
	LOCATE 1,20:PRINT "    ";:REM ERASE PRIOR ONE	
	LOCATE 1,20:PRINT "N=";RIGHT$(STR$(CR),2);
	
	REM HIGHLIGHT CURRENT DISP AND FONT SELECTION
  X = CC
	Y = CR
	D = $E7:REM YELLOW ON LIGHT BLUE
  GOSUB COLORXY	
	X = FC+28
	Y = FR
	REM (USE SAME COLOR)
	GOSUB COLORXY	
	
  RETURN
	
SHOWFONTS:
  X=1
	Y=22
	I=K1
	I2 = 0	
	COLOR 1,BG
		
SHOWFONTSA:	    
		
	ZZ=0
	IF ((I >= 32) AND (I <= 127)) THEN ZZ=1:REM PRINTABLE
	IF ((I >= 160) AND (I <= 255)) THEN ZZ=1:REM PRINTABLE	
	
	COLOR 7,BG	
	IF (X = 1) THEN LOCATE Y,X:PRINT"    ";:LOCATE Y,X:PRINT "$";HEX$(I);:LOCATE Y,X+4:ZY=5
	IF (X > 1) THEN LOCATE Y,X:ZY=1
	
	IF (I > 255) THEN PRINT "X":GOTO SKIPFONT
	IF (ZZ = 0) THEN COLOR 12,BG:PRINT CHR$($80);CHR$(I);:REM NON-PRINTABLE
	IF (ZZ <> 0) THEN COLOR 1,BG:PRINT CHR$($80);CHR$(I);:REM PRINTABLE
	REM $80 IS AN X16/COMMODORE "TRICK" TO MAKE THE NEXT CHARACTER ALWAYS PRINTABLE
	REM THE $80 IS MAINLY NEEDED IN THE CASE OF CHR$(34) DOUBLE QUOTES, TO AVOID ENTERING QUOTE-MODE
SKIPFONT:		
	X=X+ZY:I2=I2+1:REM X IS OFFSET OF EACH GROUP, I2 IS COUNT OF HOW MANY PRINTED ON THIS ROW
	IF (X>20) THEN Y=Y+1:X=1:REM PAST THE MAX COL, GO TO NEXT ROW
SHOWFONTSB:	
	I=I+1
	IF (I2 > 127) THEN GOTO SHOWFONTSEND	
	GOTO SHOWFONTSA
	
SHOWFONTSEND:  
  COLOR 3,BG
  RETURN	

SHOWDISPFONT:
  X = 1
	Y = 1	
	
	D = 0
DISPAGAIN:	
	IF (D > 255) THEN GOTO DISPEND
	
  REM GOSUB WRITEXY
	TILE X,Y,D
	X = X + 1
	IF (X > 16) THEN Y=Y+1:X=1
	D = D+1
	GOTO DISPAGAIN
	
DISPEND:REM DISPLAY END
  RETURN
	
TOGGLEBIT:

  D=FB + ((((CR-1)*16)+(CC-1))*8)	
	D=D+(FR-1):REM INCREMENT THE FONT ROW	
	V = VPEEK(1,D)	
	REM FIND THE FONT COLUMN BIT
	T = 256:REM SHOULD START AT 128 BUT FOR LOOP ALWAYS LOOPS AT LEAST ONCE
	FOR I = FC TO 1 STEP -1
	  T = INT(T/2)
	NEXT I		
	
	REM  (X OR Y) AND NOT (X AND Y)  = X XOR Y
	REM  (A + B) - 2(A AND B)        = A XOR B
	REM V = V XOR T
	V = (V + T) - 2*(V AND T)

	VPOKE 1,D,V	
		
	GOSUB MARKMODIFIED
	
  RETURN	

DOEXPORT:
  COLOR 7,BG
  LOCATE 2,19
	PRINT "WAIT";
	LOCATE 3,19
	PRINT "EXP";
	
	U1 = FB
	U2 = U1+127:REM 127 IS ONE FULL ROW OF FONT DATA (16 CHARACTERS * 8 BITS PER CHARACTER)
	IN = 1:REM CURRENT "FONT ROW" (STARTING WITH FIRST ROW)
	
	X = 28000+(CR*2000):REM BASIC LINE NUMBER	
	I2 = 0:REM ROW OF ALL FONTS
	I3 = 1:REM ROW OF CURRENT FONT BEING OUTPUT
	
NEXTGROUP:

	IF (IN = CR) THEN GOTO EXPORTCURR
	
  I2=I2+128:REM ACCOUNT FOR NOT OUTPUTING THIS
	GOTO SKIPAHEAD

EXPORTCURR:
	F$ = "@:FONT"+STR$(IN)+".BAS,S,W":REM SEQUENTIAL WRITE
  OPEN 1,8,2,F$
	LOCATE 19,1
	PRINT"     "
	LOCATE 19,1
	PRINT "ST=";ST;
	
	FOR I = U1 TO U2
	  IF (I3 = 1) THEN PRINT#1,X;" REM FONT ";INT(I2/8):X=X+10
		
		V=VPEEK(1,I)
		PRINT#1,X;" VPOKE 1,$";HEX$(I);",%",BIN$(V)
		
		X=X+10
		
		I3=I3+1
		IF (I3 > 8) THEN I3=1				
		I2=I2+1
		
  NEXT I
	
	CLOSE 1
	
SKIPAHEAD:	
	IF (IN < 16) THEN IN=IN+1:U1=U1+128:U2=U2+128:GOTO NEXTGROUP

  COLOR 1,BG
  LOCATE 2,19
	PRINT "    ";
	LOCATE 3,19
	PRINT "    ";
	
  RETURN:REM END OF DOEXPORT
	
DOIMPORTALL:
  COLOR 7,BG
  LOCATE 2,19
	PRINT "WAIT";
	LOCATE 3,19
	PRINT "IMP";
	
	BVLOAD "FONTALL.DAT",8,1,$F000	
	
  COLOR 1,BG
  LOCATE 2,19
	PRINT "    ";
	LOCATE 3,19
	PRINT "    ";

  RETURN:REM END OF DOIMPORTALL
	
DOEXPORTALL:
  COLOR 7,BG
  LOCATE 2,19
	PRINT "WAIT";
	LOCATE 3,19
	PRINT "EXP";

	F$ = "@:FONTALL.DAT,S,W":REM SEQUENTIAL WRITE
  OPEN 1,8,2,F$
	LOCATE 19,1
	PRINT"     "
	LOCATE 19,1
	PRINT "ST=";ST;
	
	U1 = $F000
	U2 = $F7FF	
	
	FOR I = U1 TO U2
	  Z = VPEEK(1,I)
		PRINT#1,CHR$(Z);
	NEXT I
	
	CLOSE 1
	
  COLOR 1,BG
  LOCATE 2,19
	PRINT "    ";
	LOCATE 3,19
	PRINT "    ";
	
  RETURN:REM END OF DOEXPORTALL	

SAVECURR:
  COLOR 7,BG
  LOCATE 2,19
	PRINT "WAIT";
	LOCATE 3,19
	PRINT "SAVE";
	
	F$ = "@:X16FONT"+STR$(CR)+".DAT,S,W":REM SEQUENTIAL WRITE
  OPEN 1,8,2,F$
	LOCATE 19,1
	PRINT"     "
	LOCATE 19,1
	PRINT "ST=";ST;
	
	IF (ST=0) THEN LOCATE CR+1,1:PRINT" ";:REM CLEAR THE MODIFIED ROW FLAG IF OPEN WITH NO ERROR
	IF (ST<>0) THEN GOTO ABORTSAVE
			
	U1=FB+(CR-1)*128
	U2=U1+127:REM 16 BYTES PER ROW
	
	FOR I = U1 TO U2
		V=VPEEK(1,I)
		PRINT#1,V		
	NEXT I	
ABORTSAVE:
	CLOSE 1
	
	COLOR 1,BG
  LOCATE 2,19
	PRINT "    ";
	LOCATE 3,19
	PRINT "    ";
	LOCATE 4,19
	PRINT "    ";
  RETURN
	
LOADCURR:
  COLOR 7,BG
  LOCATE 2,19
	PRINT "WAIT";
	LOCATE 3,19
	PRINT "LOAD";
	
	F$ = "X16FONT"+STR$(CR)+".DAT,S,R":REM SEQUENTIAL READ
  OPEN 1,8,2,F$
	LOCATE 19,1
	PRINT"     "
	LOCATE 19,1
	PRINT "ST=";ST;
	
	IF (ST=0) THEN LOCATE CR+1,1:PRINT" ";:REM CLEAR THE MODIFIED ROW FLAG IF OPEN WITH NO ERROR
	IF (ST<>0) THEN GOTO ABORTLOAD
	
	U1=FB+(CR-1)*128
	U2=U1+127:REM 8 BYTES PER FONT
	
	FOR I = U1 TO U2
		INPUT#1,V
		VPOKE 1,I,V				
	NEXT I	
	
ABORTLOAD:	
	CLOSE 1
	
	COLOR 1,BG
	LOCATE 2,19
	PRINT "    ";
	LOCATE 3,19
	PRINT "    ";
	
  RETURN	

SHOWHELP:  
  COLOR 12,BG :REM    1234567890123456789012
  LOCATE 11,19:PRINT "ARROW KEYS   MOVE FONT";	
  LOCATE 12,19:PRINT "W-A-S-D   MOVE DISPLAY";
	LOCATE 13,19:PRINT "SPACE  TOGGLE FONT BIT";
	LOCATE 14,19:PRINT "Y-G-H-J MOVE FONT BITS";
	LOCATE 15,19:PRINT "V  SAVE   X16FONTN.DAT";
	LOCATE 16,19:PRINT "L  LOAD   X16FONTN.DAT";
	LOCATE 17,19:PRINT "X  EXPORT    FONTN.BAS";
	LOCATE 18,19:PRINT "I  INVERT ROW-COL-BOTH";
	LOCATE 19,19:PRINT "[ ] DEC/INC PRINT CODE";
	LOCATE 20,19:PRINT "                      ";	
	LOCATE 21,22:PRINT "C         CLEAR ALL";
	LOCATE 22,22:PRINT "E           SET ALL";	
	LOCATE 23,22:PRINT "K         COPY CODE";
	LOCATE 24,22:PRINT "B    CYCLE BACKGRND";
	LOCATE 25,22:PRINT "Z  EXP. FONTALL.DAT";
	LOCATE 26,22:PRINT "Q  IMP. FONTALL.DAT";
	LOCATE 27,22:PRINT "ESC            EXIT";
	REM                 1234567890123456789012345678901234567890
	LOCATE 30, 1:PRINT "USE SHIFT+ALT TO RESTORE ORIGINAL FONT";
	COLOR 1,BG
	REM LOCATE 1,1:PRINT"";
	RETURN 
	
CLEARBITS:
  D=FB + ((((CR-1)*16)+(CC-1))*8)	
	CA=FR:REM STORE DOWN ORIGINAL FONT ROW
	
	FOR FR=1 TO 8
	  D1=D+(FR-1):REM INCREMENT THE FONT ROW	
	  V = $00:REM CLEAR CURRENT ROW
		VPOKE 1,D1,V	
	NEXT FR
	
	FR=CA:REM RESTORE ORIGINAL FONT ROW	
	
	GOSUB MARKMODIFIED
	
  RETURN
	
SETBITS:
  D=FB + ((((CR-1)*16)+(CC-1))*8)	
	CA=FR:REM STORE DOWN ORIGINAL FONT ROW
	
	FOR FR=1 TO 8
	  D1=D+(FR-1):REM INCREMENT THE FONT ROW	
	  V = $FF:REM SET CURRENT ROW
		VPOKE 1,D1,V	
	NEXT FR
	
	FR=CA:REM RESTORE ORIGINAL FONT ROW	
	
	GOSUB MARKMODIFIED
	
  RETURN	
	
COPYCHAR:
  COLOR 7,BG
  K$=""	
  LOCATE 20,19:PRINT "                      ";
	LOCATE 20,19:PRINT "WHICH (0-255)";
	COLOR 3,BG 
NEXTCHAR:
	GET A$
	A=ASC(A$)
	IF (A = 27) THEN GOTO COPYEXIT
	IF (A >= 48) AND (A <= 57) AND LEN(K$) < 3 THEN GOTO NUMISOK
	IF (A = 13) THEN GOTO MAKENUMBER
	IF (A = 20) THEN GOTO COPYCHAR
	GOTO NEXTCHAR
	
NUMISOK:	
  PRINT A$;
	K$=K$+A$
	GOTO NEXTCHAR
	
MAKENUMBER:
  B=VAL(K$)		
	
	IF (B = (((CR-1)*16)+(CC-1))) THEN GOTO COPYEXIT:REM TARGET/SOURCE IS SAME	
	IF (B < 0) THEN GOTO COPYEXIT
	IF (B>255) THEN GOTO COPYEXIT	
	
	REM COPY THE SPECIFIED DISPLAY FONT A INTO THE CURRENT FONT
  D=FB + ((((CR-1)*16)+(CC-1))*8):REM TARGET
	D1=FB + (B*8):REM SOURCE
	
	FOR I = 0 TO 7
	  V = VPEEK(1,D1+I)
		VPOKE 1,D+I,V
	NEXT I
		
	GOSUB MARKMODIFIED

COPYEXIT:	
  GOSUB SHOWHELP
	REM LOCATE 21,18	
	REM PRINT "                      ";
	A = 0:REM MAKE SURE INDEX VALUE ISN'T PASSED ON AS A KEYBOARD SCAN CODE IN MAIN LOOP
  RETURN	
	
CHOOSEINVERT:  
  LOCATE 20,19
	COLOR 7,BG 
	REM    1234567890123456789012
	PRINT "C=COL,R-ROW,B-BOTH/ESC";
	COLOR 3,BG
	A = 0
INVWAIT:	
	GET A$
	A = ASC(A$)
	IF A = 0 THEN GOTO INVWAIT
	
	IF A = 67 THEN GOTO INVCOLUMN:REM OPTION C
	IF A = 82 THEN GOTO INVROW:REM OPTION R
	IF A = 27 THEN GOTO INVEND:REM ESCAPE
	
	REM ELSE ASSUME BOTH (B FOR BOTH OR SPACEBAR, ETC)	
  CA=FC:REM STORE DOWN ORIGINAL CURRENT COLUMN	
	CB=FR:REM STORE DOWN ORIGINAL CURRENT ROW
	FOR FC = 1 TO 8
	  FOR FR = 1 TO 8
	    GOSUB TOGGLEBIT
		NEXT FR
	NEXT FC
	FC=CA  
	FR=CB	  
	GOTO INVEND
	
INVCOLUMN:
  CA=FR:REM STORE DOWN ORIGINAL CURRENT COLUMN	
	FOR FR = 1 TO 8
	  GOSUB TOGGLEBIT		
	NEXT FR	
	FR=CA  	
  GOTO INVEND
	
INVROW:
  CA=FC:REM STORE DOWN ORIGINAL CURRENT ROW
	FOR FC = 1 TO 8
	  GOSUB TOGGLEBIT
	NEXT FC
	FC=CA
  GOTO INVEND	
	
INVEND:	  
  REM LOCATE 21,18	
	REM REM    1234567890123456789012
	REM PRINT "                      ";
	A = 0:REM ENSURE MAIN LOOP DOESN'T GET CURRENT KEY	
	GOSUB MARKMODIFIED
	GOSUB SHOWHELP
  RETURN	
	
MOVBIToUP:
  D=FB + ((((CR-1)*16)+(CC-1))*8)		
	RT=VPEEK(1,D):REM TOP ROW  
	FOR I = 1 TO 7
	  V=VPEEK(1,(D+I))
		VPOKE 1,(D+I)-1,V	
	NEXT I
	VPOKE 1,D+7,RT
	GOSUB MARKMODIFIED
	RETURN
	
MOVBIToDOWN:	
  D=FB + ((((CR-1)*16)+(CC-1))*8)		
	RB=VPEEK(1,D+7):REM BOTTOM ROW  
	FOR I = 6 TO 0 STEP -1
	  V=VPEEK(1,(D+I))
		VPOKE 1,(D+I)+1,V	
	NEXT I
	VPOKE 1,D,RB
	GOSUB MARKMODIFIED
	RETURN
	
MOVBIToLEFT:	
  D=FB + ((((CR-1)*16)+(CC-1))*8)			
	FOR I = 0 TO 7
	  V=VPEEK(1,(D+I))
		C = (V AND $80) / 128:REM SHOULD BE 0 OR 1
		V = ((V * 2) AND $FF) OR C:REM SHIFT LEFT
		VPOKE 1,(D+I),V
	NEXT I
	GOSUB MARKMODIFIED
	RETURN
	
MOVBIToRIGHT:		
  D=FB + ((((CR-1)*16)+(CC-1))*8)			
	FOR I = 0 TO 7
	  V=VPEEK(1,(D+I))
		C = (V AND $01) * 128:REM SHOULD BE 0 OR 128
		V = (V / 2) OR C:REM SHIFT LEFT
		VPOKE 1,(D+I),V
	NEXT I
	GOSUB MARKMODIFIED
	RETURN
	
CYCLEBACKG:
  IF BG=6 THEN BG=0:B1=$01:GOTO STARTFRESH
	IF BG=0 THEN BG=6:B1=$61:GOTO STARTFRESH
	
MARKMODIFIED:
  LOCATE CR+1,1:PRINT"*";	
	RETURN
		
TERMINATE:
  LOCATE 29,1
  END	
		
REM *******************************************	
	REM USES VARIABLES:
	REM X = COLUMN TO WRITE (1-N)
	REM Y = ROW TO WRITE (1-60)
	REM D = THE DISPLAY CODE VALUE TO WRITE
	REM X,Y ARE 0 BASED HERE
	REM WRITEXY IS REPLACED BY NEW TILE COMMAND (AS OF R45)
WRITEXY:	
  VPOKE 1,VR+((Y*128)+X)*2,D
	RETURN

	REM USES VARIABLES:
	REM X = COLUMN TO WRITE (1-N)
	REM Y = ROW TO WRITE (1-60)
	REM D = THE COLOR CODE TO WRITE
	REM X,Y ARE 0 BASED HERE
COLORXY:
	VPOKE 1,VR+((Y*128)+X)*2+1,D
	RETURN	
REM *******************************************		
